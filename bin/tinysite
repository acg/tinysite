#!/usr/bin/env python

import sys
import io
import os
import errno
import optparse
import simplejson as json
from os.path import normpath
from http_parser.http import HttpStream, HTTP_REQUEST
from http_parser.util import status_reasons
from mimetypes import guess_type
from sendfile import sendfile
from templating.templater import Templater, TemplateNotFound


def main( argv, stdin, stdout, stderr ):

  # TODO add a dependency scanner mode
  prog = argv[0].split('/')[-1]
  optp = optparse.OptionParser()
  optp.add_option( '-H', '--http', help="HTTP mode. Read request from stdin, write response to stdout.", action="store_true")
  opts, args = optp.parse_args( args=argv[1:] )

  # TODO set these from environment and/or options
  config = Record()
  config.template_root = args.pop(0)
  config.content_root = args.pop(0)
  config.static_root = args.pop(0)

  if opts.http:
    ok = http_serve( config, stdin, stdout )
  else:
    ok = True
    request_path = args.pop(0)
    output = transform( config, request_path )
    print >> stdout, output,

  return 0 if ok else 100


def transform( config, path ):

  path = resolve_path( path )

  # Look for content at same path, but with markdown extension, /foo/bar.html => /foo/bar.md
  content_path = path
  if content_path.endswith('.html'):
    content_path = content_path[0:-5]+'.md'

  # Load the template.
  templater = Templater([ config.template_root ])
  template = templater.get_template( path )

  # Load the content
  data, content = load_content( config.content_root+'/'+content_path )
  data['content'] = content

  # Render and output the template.
  output = template.render( **data ).encode('utf-8')
  return output


def resolve_path( path ):

  # Sanitize request path: don't let it escape the root.
  original_path, path = path, normpath( path.lstrip('/') )
  if path.startswith('../'):
    raise InvalidRequestPath("invalid request path: %s" % original_path)
  path = '/'+path

  # Turn trailing slash into .html, /foo/bar/ => /foo/bar.html
  if path.endswith('/'):
    path = path[0:-1]+'.html'

  return path


def http_serve( config, stdin, stdout ):

  # Re-open the stdin and stdout file descriptors using raw unbuffered i/o.
  stdin = io.FileIO( stdin.fileno() )
  stdout = io.FileIO( stdout.fileno(), 'w' )

  # Parse an HTTP request on stdin.
  parser = HttpStream( stdin, kind=HTTP_REQUEST )
  wsgi_env = parser.wsgi_environ()
  request_method = wsgi_env['REQUEST_METHOD']
  request_path = wsgi_env['PATH_INFO']
  request_length = wsgi_env.get('HTTP_CONTENT_LENGTH',0)
  request_body = parser.body_file()

  try:

    success = False

    if request_method != 'GET':
      raise HttpError(405)

    path = resolve_path(request_path)
    mimetype = guess_type(request_path)[0]

    try:
      output = transform( config, request_path )
      http_respond( stdout, 200, mimetype=mimetype, body=output )
    except TemplateNotFound as e:
      # Retry as static file.
      full_static_path = config.static_root + path
      with file( full_static_path ) as static_file:
        http_respond( stdout, 200, mimetype=mimetype, body=static_file )

    success = True

  except InvalidRequestPath as e:
    http_respond(stdout, 400)
  except HttpError as e:
    http_respond(stdout, e.status)
  except IOError as e:
    if e.errno == errno.ENOENT:
      http_respond(stdout, 404)
    elif e.errno == errno.EACCES:
      http_respond(stdout, 403)
    else:
      http_respond(stdout, 500)
  except:
    http_respond(stdout, 500)

  return success


def http_respond( out, status, reason=None, version="HTTP/1.0", body=None, length=0, mimetype='text/html' ):
  # TODO prevent headers from being emitted a second time

  if isinstance(body,basestring):
    length = len(body)
  elif isinstance(body,file):
    stat = os.fstat(body.fileno())
    length = stat.st_size

  print >> out, "%s %s %s\r\n" % (version, status, reason or status_reasons[status]),
  print >> out, "Content-Length: %d\r\n" % (length),
  print >> out, "Content-Type: %s\r\n" % (mimetype),
  print >> out, "Connection: close\r\n",
  print >> out, "Date: %s\r\n" % "foo",  # TODO emit an actual http date
  print >> out, "\r\n",

  if isinstance(body,basestring):
    print >> out, body,
  elif isinstance(body,file):
    rfd = body.fileno()
    wfd = out.fileno()
    offset = 0
    while length > 0:
      sent = sendfile( wfd, rfd, offset, length )
      if sent == 0: break
      offset += sent
      length -= sent

  return


def load_content( content_path ):
  in_header = False
  data = ''
  content = ''

  with file(content_path) as f:
    for linenum, line in enumerate(f):

      if linenum == 0 and line == '{\n':
        in_header = True
      elif in_header and line == '\n':
        in_header = False

      if in_header:
        data += line
      else:
        content += line

  # TODO process embedded #include directives in the JSON here
  data = json.loads(data) if data else {}
  return data, content


class Record( dict ):
  def __getattr__( self, name ):
    return self[name]
  def __setattr__( self, name, value ):
    self[name] = value
    return value


class InvalidRequestPath(Exception): pass
class HttpError(Exception): pass   # TODO store code


if __name__ == '__main__':
  import sys
  sys.exit( main( sys.argv, sys.stdin, sys.stdout, sys.stderr ) )

