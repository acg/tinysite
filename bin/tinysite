#!/usr/bin/env python

import sys
import io
import os
import errno
import optparse
from os.path import normpath, relpath, splitext
import pkgutil
import jinja2
from jinja2.exceptions import TemplateNotFound
from http_parser.http import HttpStream, HTTP_REQUEST
from http_parser.util import status_reasons
from sendfile import sendfile
from mimetypes import guess_type
import simplejson as json
from markdown import Markdown


def main( argv, stdin, stdout, stderr ):

  # TODO add a dependency scanner mode
  prog = argv[0].split('/')[-1]
  optp = optparse.OptionParser()
  optp.add_option( '-t', '--template-root', help="Path to templates directory.", default=os.environ.get('TEMPLATE_ROOT',"templates"))
  optp.add_option( '-c', '--content-root', help="Path to content directory.", default=os.environ.get('CONTENT_ROOT',"content"))
  optp.add_option( '-s', '--static-root', help="Path to static content directory.", default=os.environ.get('STATIC_ROOT',"static"))
  opts, args = optp.parse_args( args=argv[1:] )

  config = Record()
  config.update(filter( lambda kv: kv[1] != None, vars(opts).items() ))

  command = args.pop(0) if len(args) else None

  if command == 'render':
    print >> stdout, render( config, args.pop(0) )
    ok = True
  elif command == 'httpd':
    ok = http_serve( config, stdin, stdout )
  else:
    print >> stderr, "unknown command"
    ok = False

  return 0 if ok else 100


# Core functionality.

def render( config, path ):

  path = resolve_path( path )

  # Look for content at same path, but with markdown extension, /foo/bar.html => /foo/bar.md
  content_path = path
  if content_path.endswith('.html'):
    content_path = content_path[0:-5]+'.md'

  # Load the template.
  templater = Templater([ config.template_root ])
  template = templater.get_template( path )

  # Load the content
  data, content = load_content( config.content_root+'/'+content_path )
  data['content'] = content

  # Render and output the template.
  output = template.render( **data ).encode('utf-8')
  return output


def resolve_path( path ):

  # Sanitize request path: don't let it escape the root.
  original_path, path = path, normpath( path.lstrip('/') )
  if path.startswith('../'):
    raise InvalidRequestPath("invalid request path: %s" % original_path)
  elif path == '.':
    path = ''
  path = '/'+path

  # Turn trailing slash into .html, /foo/bar/ => /foo/bar.html
  if path == '/':
    path = '/index.html'
  elif path.endswith('/'):
    path = path.rstrip('/')+'.html'

  return path


def load_content( content_path ):
  in_header = False
  data = ''
  content = ''
  with file(content_path) as f:
    for linenum, line in enumerate(f):
      # Skip an initial blank line.
      if linenum == 0 and line == '\n':
        continue
      # Recognize JSON data header.
      if linenum == 1 and line == '    {\n':
        in_header = True
      elif in_header and line == '\n':
        in_header = False
      # Accumulate data or content.
      if in_header:
        data += line
      else:
        content += line
  # TODO process embedded #include directives in the JSON here
  data = json.loads(data) if data else {}
  return data, content


# HTTP handling.

def http_serve( config, stdin, stdout ):

  # Re-open the stdin and stdout file descriptors using raw unbuffered i/o.
  stdin = io.FileIO( stdin.fileno() )
  stdout = io.FileIO( stdout.fileno(), 'w' )

  # Parse an HTTP request on stdin.
  parser = HttpStream( stdin, kind=HTTP_REQUEST )
  wsgi_env = parser.wsgi_environ()
  request_method = wsgi_env['REQUEST_METHOD']
  request_path = wsgi_env['PATH_INFO']
  request_length = wsgi_env.get('HTTP_CONTENT_LENGTH',0)
  request_body = parser.body_file()

  try:

    success = False

    if request_method != 'GET':
      raise HttpError(405)

    path = resolve_path(request_path)
    mimetype = guess_type(path)[0]

    try:
      output = render( config, request_path )
      http_respond( stdout, 200, mimetype=mimetype, body=output )
    except TemplateNotFound as e:
      # Retry as static file.
      full_static_path = config.static_root + path
      with file( full_static_path ) as static_file:
        http_respond( stdout, 200, mimetype=mimetype, body=static_file )

    success = True

  except InvalidRequestPath as e:
    http_respond(stdout, 400)
  except HttpError as e:
    http_respond(stdout, e.status)
  except IOError as e:
    if e.errno == errno.ENOENT:
      http_respond(stdout, 404)
    elif e.errno == errno.EACCES:
      http_respond(stdout, 403)
    else:
      http_respond(stdout, 500)
  except:
    http_respond(stdout, 500)

  return success


def http_respond( out, status, reason=None, version="HTTP/1.0", body=None, length=None, mimetype='text/html' ):
  # TODO prevent headers from being emitted a second time

  reason = reason or status_reasons[status]

  # Basic http error page.
  if body == None and status >= 400:
    body = "<html><body><h1>%d %s</h1></body></html>" % (status, reason)

  # Calculate content length from body.
  if length == None:
    if isinstance(body,basestring):
      length = len(body)
    elif isinstance(body,file):
      stat = os.fstat(body.fileno())
      length = stat.st_size

  # Output http headers.
  print >> out, "%s %s %s\r\n" % (version, status, reason),
  print >> out, "Content-Length: %d\r\n" % (length),
  print >> out, "Content-Type: %s\r\n" % (mimetype),
  print >> out, "Connection: close\r\n",
  print >> out, "Date: %s\r\n" % "foo",  # TODO emit an actual http date
  print >> out, "\r\n",

  # Output http body, if we have one.
  if isinstance(body,basestring):
    print >> out, body,
  elif isinstance(body,file):
    rfd = body.fileno()
    wfd = out.fileno()
    offset = 0
    while length > 0:
      sent = sendfile( wfd, rfd, offset, length )
      if sent == 0: break
      offset += sent
      length -= sent

  return


# Templating.

class Templater( object ):

  def __init__( self, template_includes=None, template_globals=None ):

    if template_includes == None:
      template_includes = []
    if template_globals == None:
      template_globals = {}

    self.template_includes = template_includes
    self.template_globals = template_globals

    # Dynamically load all the templating plugins.

    try:
      import templating.plugins as plugins_package
    except ImportError as e:
      plugins_package = None

    plugins = {}
    for module, modname in iter_package_modules(plugins_package) if plugins_package else []:
      if hasattr(module,'PLUGIN'):
        plugins[modname] = module.PLUGIN
      else:
        plugins[modname] = {}
        for name in dir(module):
          o = getattr(module,name)
          if callable(o):
            plugins[modname][name] = o

    self.plugins = plugins

    # Dynamically load all the templating filters.

    try:
      import templating.filters as filters_package
    except ImportError as e:
      filters_package = None

    filters = { 'markdown': filter_markdown }
    for module, modname in iter_package_modules(filters_package) if filters_package else []:
      if hasattr(module,'FILTER'):
        filters[modname] = module.FILTER
      else:
        for name in dir(module):
          o = getattr(module,name)
          if callable(o):
            filters[name] = o

    self.filters = filters


  def get_template( self, template, other_globals=None ):

    # Allow template paths that are absolute, or that are relative to the
    # current working directory, so long as they can be resolved to a
    # path relative to one of the allowed template inclusion directories.

    for incdir in self.template_includes:
      p = relpath(abspath(template), start=abspath(incdir))
      if not p.startswith('/') and not p.startswith('../'):
        template = p
        break

    ext = splitext(template)[1]

    # Set up and create a template object.

    jinja_loader = jinja2.FileSystemLoader( self.template_includes )
    jinja_env = RelativeEnvironment( loader=jinja_loader, autoescape=(ext in ('.html','.xml')), extensions=['jinja2.ext.autoescape'] )
    jinja_env.filters.update( self.filters )
    jinja_env.globals.update( plugins=self.plugins )
    jinja_env.globals.update( self.template_globals )
    jinja_env.globals.update( other_globals if other_globals else {} )
    jinja_template = jinja_env.get_template( template )

    return jinja_template


def filter_markdown(value):
  if not value: return value
  md = Markdown()
  return md.convert(unicode(value))


def abspath( path ):
  """ Unfortunately, os.path.abspath does some physical cleanup. """
  if path.startswith('/'):
    return path
  else:
    return normpath(os.environ['PWD']+'/'+path)


class RelativeEnvironment(jinja2.Environment):
  """ Override join_path() to enable relative template paths. """
  def join_path(self, template, parent):
    return normpath(os.path.join(os.path.dirname(parent), template))


def iter_package_modules( pkg ):
  for importer, modname, _ in pkgutil.iter_modules( pkg.__path__ ):
    full_package_name = "%s.%s" % ( pkg.__name__, modname )
    if full_package_name not in sys.modules:
      module = importer.find_module(modname).load_module(full_package_name)
      yield module, modname


# Convenience class. A dict that allows foo.bar instead of just foo["bar"].

class Record( dict ):
  def __getattr__( self, name ):
    return self[name]
  def __setattr__( self, name, value ):
    self[name] = value
    return value


# Exception types.

class InvalidRequestPath(Exception): pass

class HttpError(Exception):
  def __init__(self, status):
    self.status = status
    self.message = "HTTP Error %d" % status


# Driver.

if __name__ == '__main__':
  import sys
  sys.exit( main( sys.argv, sys.stdin, sys.stdout, sys.stderr ) )

