#!/usr/bin/env python

import sys
import io
import os
import time
import errno
import optparse
from os.path import normpath, relpath, dirname, splitext
import pkgutil
import jinja2
import jinja2.meta
from jinja2.exceptions import TemplateNotFound
from http_parser.http import HttpStream, HTTP_REQUEST
from http_parser.util import status_reasons
from sendfile import sendfile
from mimetypes import guess_type
import simplejson as json
from markdown import Markdown
from ddata import dwalk, dmerge, DOP


def main( argv, stdin, stdout, stderr ):

  prog = argv[0].split('/')[-1]
  optp = optparse.OptionParser()
  optp.add_option( '-t', '--template-root', help="Path to templates directory.", default=os.environ.get('TEMPLATE_ROOT',"templates"))
  optp.add_option( '-c', '--content-root', help="Path to content directory.", default=os.environ.get('CONTENT_ROOT',"content"))
  optp.add_option( '-s', '--static-root', help="Path to static content directory.", default=os.environ.get('STATIC_ROOT',"static"))
  opts, args = optp.parse_args( args=argv[1:] )

  config = Record()
  config.update(filter( lambda kv: kv[1] != None, vars(opts).items() ))

  command = args.pop(0) if len(args) else None

  if command == 'render':
    print >> stdout, render( config, args.pop(0) )
    ok = True
  elif command == 'scan':
    for srcpath, dstpath in scan( config, args.pop(0) ):
      print "%s : %s\n\n" % (srcpath,dstpath),
    ok = True
  elif command == 'httpd':
    ok = http_serve( config, stdin, stdout )
  else:
    print >> stderr, "unknown command"
    ok = False

  return 0 if ok else 100


# Core functionality.

def render( config, path ):

  path = resolve_path( path )

  # Look for content at same path, but with markdown extension, /foo/bar.html => /foo/bar.md
  content_path = path
  if content_path.endswith('.html'):
    content_path = content_path[0:-5]+'.md'

  # Load the template.
  templater = Templater([ config.template_root ])
  template = templater.get_template( path )

  # Load the content
  data, content = load_content( config.content_root+'/'+content_path )
  data['content'] = content

  # Render and output the template.
  output = template.render( **data ).encode('utf-8')
  return output


def resolve_path( path ):

  # Sanitize request path: don't let it escape the root.
  original_path, path = path, normpath( path.lstrip('/') )
  if path.startswith('../'):
    raise InvalidRequestPath("invalid request path: %s" % original_path)
  elif path == '.':
    path = ''
  path = '/'+path

  # Turn trailing slash into .html, /foo/bar/ => /foo/bar.html
  if path == '/':
    path = '/index.html'
  elif path.endswith('/'):
    path = path.rstrip('/')+'.html'

  return path


def load_content( content_path, expand=True ):
  in_header = False
  data = ''
  content = ''
  with file(content_path) as f:
    for linenum, line in enumerate(f):
      # Skip an initial blank line.
      if linenum == 0 and line == '\n':
        continue
      # Recognize JSON data header.
      if linenum == 1 and line == '    {\n':
        in_header = True
      elif in_header and line == '\n':
        in_header = False
      # Accumulate data or content.
      if in_header:
        data += line
      else:
        content += line
  data = json.loads(data) if data else {}
  data = expand_data( data, content_path ) if expand else data
  return data, content


def expand_data( data, filepath ):

  cwd = dirname(filepath)

  def expand_visitor( data, datapath ):

    if not len(datapath): return
    if not datapath[-1] in ['#include','#load','#extend']: return

    directive = datapath[-1]
    incdata = {}

    for relpath in [ "%s/%s" % (cwd,incpath) for incpath in data ]:
      if relpath.endswith('.json'):
        with file(relpath) as f:
          d = json.load(f)
        if directive != '#load':
          expand_data( d, relpath )
      else:
        with file(relpath) as f:
          d = f.read()
      incdata = dmerge( incdata, d )

    if directive == '#include' or directive == '#load':
      return DOP( op='update',  key=datapath[-1], val=incdata )
    elif directive == '#extend':
      return DOP( op='prepend', key=datapath[-1], val=incdata )

  def expand_orderer( a, b ):
    # When walking dictionaries, we need to encounter #extend directives first.
    return -(cmp(a=='#extend',b=='#extend')) or cmp(a,b)

  return dwalk( data, expand_visitor, expand_orderer )


def scan_data( data, filepath, dependencies=None, scanned=None ):

  dependencies = dependencies or []
  scanned = scanned or set()
  filepath = normpath(filepath)
  scanned.add(filepath)
  cwd = dirname(filepath)

  def scan_visitor( data, datapath ):
    if not len(datapath): return
    if not datapath[-1] in ['#include','#load','#extend']: return
    directive = datapath[-1]

    for relpath in [ normpath("%s/%s" % (cwd,incpath)) for incpath in data ]:
      dependencies.append( (filepath,relpath,) )
      if relpath in scanned: continue
      if relpath.endswith('.json') and directive != '#load':
        with file(relpath) as f:
          d = json.load(f)
          scan_data( d, relpath, dependencies, scanned )

  dwalk( data, scan_visitor )
  return dependencies


# File dependency scanning.

def scan( config, path ):

  transitive_dependencies = []
  static_path = config.static_root + path

  # Content dependencies.

  content_path = config.content_root + path
  if content_path.endswith(".html"): content_path = content_path[:-5]+".md"
  data, content = load_content( content_path, expand=False )
  content_dependencies = scan_data( data, content_path )
  for srcpath, dstpath in content_dependencies:
    if srcpath == content_path:
      transitive_dependencies.append( (static_path,dstpath,) )

  # Template dependencies.

  template_path = config.template_root + path
  templater = Templater([ config.template_root ])
  template_dependencies = templater.scan_template( template_path )
  for srcpath, dstpath in template_dependencies:
    if srcpath == template_path:
      transitive_dependencies.append( (static_path,dstpath,) )

  return transitive_dependencies + content_dependencies + template_dependencies


# HTTP handling.

def http_serve( config, stdin, stdout ):

  # Re-open the stdin and stdout file descriptors using raw unbuffered i/o.
  stdin = io.FileIO( stdin.fileno() )
  stdout = io.FileIO( stdout.fileno(), 'w' )

  # Parse an HTTP request on stdin.
  parser = HttpStream( stdin, kind=HTTP_REQUEST )
  wsgi_env = parser.wsgi_environ()
  request_method = wsgi_env['REQUEST_METHOD']
  request_path = wsgi_env['PATH_INFO']
  request_length = wsgi_env.get('HTTP_CONTENT_LENGTH',0)
  request_body = parser.body_file()

  try:

    success = False

    if request_method != 'GET':
      raise HttpError(405)

    path = resolve_path(request_path)
    mimetype = guess_type(path)[0]

    try:
      output = render( config, request_path )
      http_respond( stdout, 200, mimetype=mimetype, body=output )
    except TemplateNotFound as e:
      # Retry as static file.
      full_static_path = config.static_root + path
      with file( full_static_path ) as static_file:
        http_respond( stdout, 200, mimetype=mimetype, body=static_file )

    success = True

  except InvalidRequestPath as e:
    http_respond(stdout, 400)
  except HttpError as e:
    http_respond(stdout, e.status)
  except IOError as e:
    if e.errno == errno.ENOENT:
      http_respond(stdout, 404)
    elif e.errno == errno.EACCES:
      http_respond(stdout, 403)
    else:
      http_respond(stdout, 500)
  except:
    http_respond(stdout, 500)

  return success


def http_respond( out, status, reason=None, version="HTTP/1.0", body=None, length=None, mimetype='text/html' ):
  # TODO prevent headers from being emitted a second time

  reason = reason or status_reasons[status]

  # Basic http error page.
  if body == None and status >= 400:
    body = "<html><body><h1>%d %s</h1></body></html>" % (status, reason)

  # Calculate content length from body.
  if length == None:
    if isinstance(body,basestring):
      length = len(body)
    elif isinstance(body,file):
      stat = os.fstat(body.fileno())
      length = stat.st_size

  # Output http headers.
  print >> out, "%s %s %s\r\n" % (version, status, reason),
  print >> out, "Content-Length: %d\r\n" % (length),
  print >> out, "Content-Type: %s\r\n" % (mimetype),
  print >> out, "Connection: close\r\n",
  print >> out, "Date: %s\r\n" % time.strftime("%a, %d %b %Y %T %z"),
  print >> out, "\r\n",

  # Output http body, if we have one.
  if isinstance(body,basestring):
    print >> out, body,
  elif isinstance(body,file):
    rfd = body.fileno()
    wfd = out.fileno()
    offset = 0
    while length > 0:
      sent = sendfile( wfd, rfd, offset, length )
      if sent == 0: break
      offset += sent
      length -= sent

  return


# Templating.

class Templater( object ):

  def __init__( self, template_includes=None, template_globals=None ):

    if template_includes == None:
      template_includes = []
    if template_globals == None:
      template_globals = {}

    self.template_includes = template_includes
    self.template_globals = template_globals

    # Dynamically load all the templating plugins.

    try:
      import templating.plugins as plugins_package
    except ImportError as e:
      plugins_package = None

    plugins = {}
    for module, modname in iter_package_modules(plugins_package) if plugins_package else []:
      if hasattr(module,'PLUGIN'):
        plugins[modname] = module.PLUGIN
      else:
        plugins[modname] = {}
        for name in dir(module):
          o = getattr(module,name)
          if callable(o):
            plugins[modname][name] = o

    self.plugins = plugins

    # Dynamically load all the templating filters.

    try:
      import templating.filters as filters_package
    except ImportError as e:
      filters_package = None

    filters = { 'markdown': filter_markdown }
    for module, modname in iter_package_modules(filters_package) if filters_package else []:
      if hasattr(module,'FILTER'):
        filters[modname] = module.FILTER
      else:
        for name in dir(module):
          o = getattr(module,name)
          if callable(o):
            filters[name] = o

    self.filters = filters


  def get_template( self, template, other_globals=None ):

    templatedir, template = self.resolve_template( template )
    ext = splitext(template)[1]

    # Set up and create a template object.

    jinja_env = self.get_environment( autoescape=(ext in ('.html','.xml')), extensions=['jinja2.ext.autoescape'], other_globals=other_globals )
    jinja_template = jinja_env.get_template( template )

    return jinja_template


  def scan_template( self, template, dependencies=None, scanned=None ):

    dependencies = dependencies or []
    scanned = scanned or set()
    templatedir, template = self.resolve_template( template )
    templatepath = "%s/%s" % (templatedir,template)
    scanned.add(templatepath)
    cwd = dirname(templatepath)

    jinja_env = self.get_environment()
    source = file(templatepath).read()
    jinja_ast = jinja_env.parse( source, filename=templatepath )

    for refpath in list(jinja2.meta.find_referenced_templates(jinja_ast)):
      if not refpath: continue
      refpath = normpath( "%s/%s" % (cwd,refpath) )
      dependencies.append( (templatepath,refpath), )
      if not refpath in scanned:
        self.scan_template( refpath, dependencies, scanned )

    return dependencies


  def resolve_template( self, template, extra_includes=None ):

    # Allow template paths that are absolute, or that are relative to the
    # current working directory, so long as they can be resolved to a
    # path relative to one of the allowed template inclusion directories.

    templatedir = None
    extra_includes = extra_includes or []

    for incdir in extra_includes + self.template_includes:
      p = relpath(abspath(template), start=abspath(incdir))
      if not p.startswith('/') and not p.startswith('../'):
        templatedir = incdir
        template = p
        break

    return templatedir, template


  def get_environment( self, autoescape=True, extensions=None, other_globals=None ):

    # Set up and create a jinja template environment.

    jinja_loader = jinja2.FileSystemLoader( self.template_includes )
    jinja_env = RelativeEnvironment( loader=jinja_loader, autoescape=autoescape, extensions=(extensions or []) )
    jinja_env.filters.update( self.filters )
    jinja_env.globals.update( plugins=self.plugins )
    jinja_env.globals.update( self.template_globals )
    jinja_env.globals.update( other_globals if other_globals else {} )

    return jinja_env



def filter_markdown(value):
  if not value: return value
  md = Markdown()
  return md.convert(unicode(value))


def abspath( path ):
  """ Unfortunately, os.path.abspath does some physical cleanup. """
  if path.startswith('/'):
    return path
  else:
    return normpath(os.environ['PWD']+'/'+path)


class RelativeEnvironment(jinja2.Environment):
  """ Override join_path() to enable relative template paths. """
  def join_path(self, template, parent):
    return normpath(os.path.join(os.path.dirname(parent), template))


def iter_package_modules( pkg ):
  for importer, modname, _ in pkgutil.iter_modules( pkg.__path__ ):
    full_package_name = "%s.%s" % ( pkg.__name__, modname )
    if full_package_name not in sys.modules:
      module = importer.find_module(modname).load_module(full_package_name)
      yield module, modname


# Convenience class. A dict that allows foo.bar instead of just foo["bar"].

class Record( dict ):
  def __getattr__( self, name ):
    return self[name]
  def __setattr__( self, name, value ):
    self[name] = value
    return value


# Exception types.

class InvalidRequestPath(Exception): pass

class HttpError(Exception):
  def __init__(self, status):
    self.status = status
    self.message = "HTTP Error %d" % status


# Driver.

if __name__ == '__main__':
  import sys
  sys.exit( main( sys.argv, sys.stdin, sys.stdout, sys.stderr ) )

